/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.20.3
 * source: proto/obsidan-events.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export class ObsidianEvent extends pb_1.Message {
    #one_of_decls: number[][] = [[2, 3, 4, 5, 6]];
    constructor(data?: any[] | ({
        timestamp?: number;
    } & (({
        create?: CreateEvent;
        delete?: never;
        rename?: never;
        modify?: never;
        fileOpen?: never;
    } | {
        create?: never;
        delete?: DeleteEvent;
        rename?: never;
        modify?: never;
        fileOpen?: never;
    } | {
        create?: never;
        delete?: never;
        rename?: RenameEvent;
        modify?: never;
        fileOpen?: never;
    } | {
        create?: never;
        delete?: never;
        rename?: never;
        modify?: ModifyEvent;
        fileOpen?: never;
    } | {
        create?: never;
        delete?: never;
        rename?: never;
        modify?: never;
        fileOpen?: FileOpenEvent;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("timestamp" in data && data.timestamp != undefined) {
                this.timestamp = data.timestamp;
            }
            if ("create" in data && data.create != undefined) {
                this.create = data.create;
            }
            if ("delete" in data && data.delete != undefined) {
                this.delete = data.delete;
            }
            if ("rename" in data && data.rename != undefined) {
                this.rename = data.rename;
            }
            if ("modify" in data && data.modify != undefined) {
                this.modify = data.modify;
            }
            if ("fileOpen" in data && data.fileOpen != undefined) {
                this.fileOpen = data.fileOpen;
            }
        }
    }
    get timestamp() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set timestamp(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get create() {
        return pb_1.Message.getWrapperField(this, CreateEvent, 2) as CreateEvent;
    }
    set create(value: CreateEvent) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_create() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get delete() {
        return pb_1.Message.getWrapperField(this, DeleteEvent, 3) as DeleteEvent;
    }
    set delete(value: DeleteEvent) {
        pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_delete() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get rename() {
        return pb_1.Message.getWrapperField(this, RenameEvent, 4) as RenameEvent;
    }
    set rename(value: RenameEvent) {
        pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
    }
    get has_rename() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get modify() {
        return pb_1.Message.getWrapperField(this, ModifyEvent, 5) as ModifyEvent;
    }
    set modify(value: ModifyEvent) {
        pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
    }
    get has_modify() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get fileOpen() {
        return pb_1.Message.getWrapperField(this, FileOpenEvent, 6) as FileOpenEvent;
    }
    set fileOpen(value: FileOpenEvent) {
        pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
    }
    get has_fileOpen() {
        return pb_1.Message.getField(this, 6) != null;
    }
    get event() {
        const cases: {
            [index: number]: "none" | "create" | "delete" | "rename" | "modify" | "fileOpen";
        } = {
            0: "none",
            2: "create",
            3: "delete",
            4: "rename",
            5: "modify",
            6: "fileOpen"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2, 3, 4, 5, 6])];
    }
    static fromObject(data: {
        timestamp?: number;
        create?: ReturnType<typeof CreateEvent.prototype.toObject>;
        delete?: ReturnType<typeof DeleteEvent.prototype.toObject>;
        rename?: ReturnType<typeof RenameEvent.prototype.toObject>;
        modify?: ReturnType<typeof ModifyEvent.prototype.toObject>;
        fileOpen?: ReturnType<typeof FileOpenEvent.prototype.toObject>;
    }): ObsidianEvent {
        const message = new ObsidianEvent({});
        if (data.timestamp != null) {
            message.timestamp = data.timestamp;
        }
        if (data.create != null) {
            message.create = CreateEvent.fromObject(data.create);
        }
        if (data.delete != null) {
            message.delete = DeleteEvent.fromObject(data.delete);
        }
        if (data.rename != null) {
            message.rename = RenameEvent.fromObject(data.rename);
        }
        if (data.modify != null) {
            message.modify = ModifyEvent.fromObject(data.modify);
        }
        if (data.fileOpen != null) {
            message.fileOpen = FileOpenEvent.fromObject(data.fileOpen);
        }
        return message;
    }
    toObject() {
        const data: {
            timestamp?: number;
            create?: ReturnType<typeof CreateEvent.prototype.toObject>;
            delete?: ReturnType<typeof DeleteEvent.prototype.toObject>;
            rename?: ReturnType<typeof RenameEvent.prototype.toObject>;
            modify?: ReturnType<typeof ModifyEvent.prototype.toObject>;
            fileOpen?: ReturnType<typeof FileOpenEvent.prototype.toObject>;
        } = {};
        if (this.timestamp != null) {
            data.timestamp = this.timestamp;
        }
        if (this.create != null) {
            data.create = this.create.toObject();
        }
        if (this.delete != null) {
            data.delete = this.delete.toObject();
        }
        if (this.rename != null) {
            data.rename = this.rename.toObject();
        }
        if (this.modify != null) {
            data.modify = this.modify.toObject();
        }
        if (this.fileOpen != null) {
            data.fileOpen = this.fileOpen.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.timestamp != 0)
            writer.writeInt64(1, this.timestamp);
        if (this.has_create)
            writer.writeMessage(2, this.create, () => this.create.serialize(writer));
        if (this.has_delete)
            writer.writeMessage(3, this.delete, () => this.delete.serialize(writer));
        if (this.has_rename)
            writer.writeMessage(4, this.rename, () => this.rename.serialize(writer));
        if (this.has_modify)
            writer.writeMessage(5, this.modify, () => this.modify.serialize(writer));
        if (this.has_fileOpen)
            writer.writeMessage(6, this.fileOpen, () => this.fileOpen.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ObsidianEvent {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ObsidianEvent();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.timestamp = reader.readInt64();
                    break;
                case 2:
                    reader.readMessage(message.create, () => message.create = CreateEvent.deserialize(reader));
                    break;
                case 3:
                    reader.readMessage(message.delete, () => message.delete = DeleteEvent.deserialize(reader));
                    break;
                case 4:
                    reader.readMessage(message.rename, () => message.rename = RenameEvent.deserialize(reader));
                    break;
                case 5:
                    reader.readMessage(message.modify, () => message.modify = ModifyEvent.deserialize(reader));
                    break;
                case 6:
                    reader.readMessage(message.fileOpen, () => message.fileOpen = FileOpenEvent.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ObsidianEvent {
        return ObsidianEvent.deserialize(bytes);
    }
}
export class CreateEvent extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        filePath?: string;
        content?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("filePath" in data && data.filePath != undefined) {
                this.filePath = data.filePath;
            }
            if ("content" in data && data.content != undefined) {
                this.content = data.content;
            }
        }
    }
    get filePath() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set filePath(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get content() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set content(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        filePath?: string;
        content?: string;
    }): CreateEvent {
        const message = new CreateEvent({});
        if (data.filePath != null) {
            message.filePath = data.filePath;
        }
        if (data.content != null) {
            message.content = data.content;
        }
        return message;
    }
    toObject() {
        const data: {
            filePath?: string;
            content?: string;
        } = {};
        if (this.filePath != null) {
            data.filePath = this.filePath;
        }
        if (this.content != null) {
            data.content = this.content;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.filePath.length)
            writer.writeString(1, this.filePath);
        if (this.content.length)
            writer.writeString(2, this.content);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateEvent {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateEvent();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.filePath = reader.readString();
                    break;
                case 2:
                    message.content = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): CreateEvent {
        return CreateEvent.deserialize(bytes);
    }
}
export class DeleteEvent extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        filePath?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("filePath" in data && data.filePath != undefined) {
                this.filePath = data.filePath;
            }
        }
    }
    get filePath() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set filePath(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        filePath?: string;
    }): DeleteEvent {
        const message = new DeleteEvent({});
        if (data.filePath != null) {
            message.filePath = data.filePath;
        }
        return message;
    }
    toObject() {
        const data: {
            filePath?: string;
        } = {};
        if (this.filePath != null) {
            data.filePath = this.filePath;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.filePath.length)
            writer.writeString(1, this.filePath);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DeleteEvent {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DeleteEvent();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.filePath = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): DeleteEvent {
        return DeleteEvent.deserialize(bytes);
    }
}
export class RenameEvent extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        newPath?: string;
        oldPath?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("newPath" in data && data.newPath != undefined) {
                this.newPath = data.newPath;
            }
            if ("oldPath" in data && data.oldPath != undefined) {
                this.oldPath = data.oldPath;
            }
        }
    }
    get newPath() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set newPath(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get oldPath() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set oldPath(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        newPath?: string;
        oldPath?: string;
    }): RenameEvent {
        const message = new RenameEvent({});
        if (data.newPath != null) {
            message.newPath = data.newPath;
        }
        if (data.oldPath != null) {
            message.oldPath = data.oldPath;
        }
        return message;
    }
    toObject() {
        const data: {
            newPath?: string;
            oldPath?: string;
        } = {};
        if (this.newPath != null) {
            data.newPath = this.newPath;
        }
        if (this.oldPath != null) {
            data.oldPath = this.oldPath;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.newPath.length)
            writer.writeString(1, this.newPath);
        if (this.oldPath.length)
            writer.writeString(2, this.oldPath);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RenameEvent {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RenameEvent();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.newPath = reader.readString();
                    break;
                case 2:
                    message.oldPath = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): RenameEvent {
        return RenameEvent.deserialize(bytes);
    }
}
export class ModifyEvent extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        filePath?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("filePath" in data && data.filePath != undefined) {
                this.filePath = data.filePath;
            }
        }
    }
    get filePath() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set filePath(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        filePath?: string;
    }): ModifyEvent {
        const message = new ModifyEvent({});
        if (data.filePath != null) {
            message.filePath = data.filePath;
        }
        return message;
    }
    toObject() {
        const data: {
            filePath?: string;
        } = {};
        if (this.filePath != null) {
            data.filePath = this.filePath;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.filePath.length)
            writer.writeString(1, this.filePath);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ModifyEvent {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ModifyEvent();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.filePath = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ModifyEvent {
        return ModifyEvent.deserialize(bytes);
    }
}
export class FileOpenEvent extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        filePath?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("filePath" in data && data.filePath != undefined) {
                this.filePath = data.filePath;
            }
        }
    }
    get filePath() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set filePath(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        filePath?: string;
    }): FileOpenEvent {
        const message = new FileOpenEvent({});
        if (data.filePath != null) {
            message.filePath = data.filePath;
        }
        return message;
    }
    toObject() {
        const data: {
            filePath?: string;
        } = {};
        if (this.filePath != null) {
            data.filePath = this.filePath;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.filePath.length)
            writer.writeString(1, this.filePath);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileOpenEvent {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileOpenEvent();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.filePath = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): FileOpenEvent {
        return FileOpenEvent.deserialize(bytes);
    }
}
export class Empty extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") { }
    }
    static fromObject(data: {}): Empty {
        const message = new Empty({});
        return message;
    }
    toObject() {
        const data: {} = {};
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Empty {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Empty();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Empty {
        return Empty.deserialize(bytes);
    }
}
interface GrpcUnaryServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
}
interface GrpcStreamServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
}
interface GrpWritableServiceInterface<P, R> {
    (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
}
interface GrpcChunkServiceInterface<P, R> {
    (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
}
interface GrpcPromiseServiceInterface<P, R> {
    (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
    (message: P, options?: grpc_1.CallOptions): Promise<R>;
}
export abstract class UnimplementedObsidianEventStreamService {
    static definition = {
        streamEvents: {
            path: "/ObsidianEventStream/streamEvents",
            requestStream: true,
            responseStream: false,
            requestSerialize: (message: ObsidianEvent) => Buffer.from(message.serialize()),
            requestDeserialize: (bytes: Buffer) => ObsidianEvent.deserialize(new Uint8Array(bytes)),
            responseSerialize: (message: Empty) => Buffer.from(message.serialize()),
            responseDeserialize: (bytes: Buffer) => Empty.deserialize(new Uint8Array(bytes))
        }
    };
    [method: string]: grpc_1.UntypedHandleCall;
    abstract streamEvents(call: grpc_1.ServerReadableStream<ObsidianEvent, Empty>, callback: grpc_1.sendUnaryData<Empty>): void;
}
export class ObsidianEventStreamClient extends grpc_1.makeGenericClientConstructor(UnimplementedObsidianEventStreamService.definition, "ObsidianEventStream", {}) {
    constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
        super(address, credentials, options);
    }
    streamEvents: GrpWritableServiceInterface<ObsidianEvent, Empty> = (metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<Empty>, options?: grpc_1.CallOptions | grpc_1.requestCallback<Empty>, callback?: grpc_1.requestCallback<Empty>): grpc_1.ClientWritableStream<ObsidianEvent> => {
        return super.streamEvents(metadata, options, callback);
    };
}
